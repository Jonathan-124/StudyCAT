{% extends 'base.html' %}

{% block title %}{{ unit.name }}{% endblock title %}

{% block content %}

<h2>{{ unit.name }}</h2>
<br>
<div id="unit-lessons" class="jumbotron">
    <div class="card-deck" id="prerequisite">
        <div class="card text-center">
            <div class="card-body">
                <h5>Prerequisite Topics</h5>
            </div>
        </div>
    </div>
</div>

<script>
$(document).ready(function(){
    const lessons_url = "http://127.0.0.1:8000/lessons/";
    let unit_lessons = document.getElementById("unit-lessons");
    let parent_adjacency_matrix;
    let child_adjacency_matrix;
    let user_skill_vector;
    let traversed_topological_orders = new Set();
    let remaining_topological_orders = new Set();

    $.get("{% url 'subjects:get_subject_dependency_matrix' 'mathematics' %}", function(data, status){
        // Retrieves user skill level array (topological order) and parent adjacency matrix from server
        // child adjacency matrix is the transpose of parent adjacency matrix
        parent_adjacency_matrix = data.dependencies;
        child_adjacency_matrix = parent_adjacency_matrix[0].map((col, i) => parent_adjacency_matrix.map(row => row[i]));
    }).then(function(){
    $.get("{% url 'userprofiles:get_subject_skills' 'mathematics' %}", function(data, status){
        user_skill_vector = data.skill_level_list;
    });
    }).then(function(){
    $.get("{% url 'units:get_unit_data' unit.id %}", function(data, status){
        for (i = 0; i < data.lessons.length; i++){
            parent_ids = new Set();
            parent_adjacency_matrix[data.lessons[i].topological_order].forEach(function(value, index, array){
                if (value == 1){
                    parent_ids.add(index)
                }
            });
            data.lessons[i]["parent_ids"] = parent_ids;
            remaining_topological_orders.add(data.lessons[i].topological_order);
        }

        while (remaining_topological_orders.size > 0){
            let deck = document.createElement("div");
            deck.setAttribute("class", "card-deck");
            unit_lessons.appendChild(document.createElement("br"));
            unit_lessons.appendChild(document.createElement("br"));
            unit_lessons.appendChild(deck);

            nl = data.lessons.filter(function(value){
                if (traversed_topological_orders.has(value.topological_order)){
                    return false
                }
                for (elem of remaining_topological_orders){
                    if (value.parent_ids.has(elem)){
                        return false
                    }
                }
                return true
            });

            for (x of nl){
                // Initializing card, card_body, link, and title vars
                let card = document.createElement("div");
                let card_body = document.createElement("div");
                let lesson_link = document.createElement("a");
                let card_title = document.createElement("h5");
                // Setting attributes
                card_title.setAttribute("class", "card-title");
                card_title.innerHTML = x.lesson_title;
                lesson_link.setAttribute("href", lessons_url.concat(x.slug));
                card_body.setAttribute("class", "card-body");
                card.setAttribute("id", x.slug);
                card.setAttribute("data-topological-order", x.topological_order);
                card.setAttribute("class", "card text-center");
                // Appending children
                lesson_link.appendChild(card_title);
                card_body.appendChild(lesson_link);
                card.appendChild(card_body);
                deck.appendChild(card);

                for (i of Array.from(x.parent_ids)){
                    if (traversed_topological_orders.has(i)){
                        parent_card_id = $(`div[data-topological-order="${i}"]`).attr('id');
                        jsPlumb.connect({source: parent_card_id,
                                         target: x.slug,
                                         endpoint:"Blank",
                                         anchor:"AutoDefault",
                                         connector:["Bezier"]});
                    } else {
                        jsPlumb.connect({source: "prerequisite",
                                         target: x.slug,
                                         endpoint:"Blank",
                                         anchor:"AutoDefault",
                                         connector:["Bezier"]});
                    }
                }
            }

            for (elem of nl){
                remaining_topological_orders.delete(elem.topological_order);
                traversed_topological_orders.add(elem.topological_order);
            }
        }
    });
    }).then(function(){
        jsPlumb.repaintEverything();
        $(window).resize(function(){
            jsPlumb.repaintEverything();
        });
    });
});
</script>

{% endblock content %}

